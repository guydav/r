apply(mpval,2, function(x) length(x>0.05))
apply(mstat,2, function(x) length(x>qchisq(0.95,3)))
??txtProgressBar
?txtProgressBar
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
	H0 <- h0#
H01 <- h0#
H01[["t1"]] <- H01[["t1"]]+ 1/sqrt(T)#
H01[["t2"]] <- H01[["t2"]]+ 1/sqrt(T)#
H01[["t3"]] <- H01[["t3"]]+ 1/sqrt(n)#
#
nsim <- 1000#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- NULL#
mstat <- NULL#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
   #
	g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
    	y <- exp(g1-g0)#
 	df <- length(H0)#
	myphi <- function(x) 1-x+x*log(x)#
#
       stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	pvalue <- 1-pchisq(stat, df=df)#
#
       for(i in 1:n.lambda){#
        myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
#
    	 stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	 pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	}#
#
 setTxtProgressBar(pb, sim)#
 mstat <- rbind(mstat, stat)#
 mpval <- rbind(mpval, pvalue)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(x>0.05))#
apply(mstat,2, function(x) length(x>qchisq(0.95,3)))
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
	H0 <- h0#
H01 <- h0#
h <- 0.5#
#
H01[["t1"]] <- H01[["t1"]]+ h/sqrt(T)#
H01[["t2"]] <- H01[["t2"]]+ h/sqrt(T)#
H01[["t3"]] <- H01[["t3"]]+ h/sqrt(n)#
#
nsim <- 100#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- NULL#
mstat <- NULL#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
   #
	g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
    	y <- exp(g1-g0)#
 	df <- length(H0)#
	myphi <- function(x) 1-x+x*log(x)#
#
       stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	pvalue <- 1-pchisq(stat, df=df)#
#
       for(i in 1:n.lambda){#
        myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
#
    	 stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	 pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	}#
#
 setTxtProgressBar(pb, sim)#
 mstat <- rbind(mstat, stat)#
 mpval <- rbind(mpval, pvalue)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(x>0.05))#
apply(mstat,2, function(x) length(x>qchisq(0.95,3)))
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
	H0 <- h0#
H01 <- h0#
h <- 1.5#
#
H01[["t1"]] <- H01[["t1"]]+ h/sqrt(T)#
H01[["t2"]] <- H01[["t2"]]+ h/sqrt(T)#
H01[["t3"]] <- H01[["t3"]]+ h/sqrt(n)#
#
nsim <- 10#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- NULL#
mstat <- NULL#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
   #
	g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
    	y <- exp(g1-g0)#
 	df <- length(H0)#
	myphi <- function(x) 1-x+x*log(x)#
#
       stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	pvalue <- 1-pchisq(stat, df=df)#
#
       for(i in 1:n.lambda){#
        myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
#
    	 stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	 pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	}#
#
 setTxtProgressBar(pb, sim)#
 mstat <- rbind(mstat, stat)#
 mpval <- rbind(mpval, pvalue)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(x>0.05))#
apply(mstat,2, function(x) length(x>qchisq(0.95,3)))
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
	H0 <- h0#
H01 <- h0#
h <- 5#
#
H01[["t1"]] <- H01[["t1"]]+ h/sqrt(T)#
H01[["t2"]] <- H01[["t2"]]+ h/sqrt(T)#
H01[["t3"]] <- H01[["t3"]]+ h/sqrt(n)#
#
nsim <- 10#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- NULL#
mstat <- NULL#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
   #
	g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
    	y <- exp(g1-g0)#
 	df <- length(H0)#
	myphi <- function(x) 1-x+x*log(x)#
#
       stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	pvalue <- 1-pchisq(stat, df=df)#
#
       for(i in 1:n.lambda){#
        myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
#
    	 stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	 pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	}#
#
 setTxtProgressBar(pb, sim)#
 mstat <- rbind(mstat, stat)#
 mpval <- rbind(mpval, pvalue)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(x>0.05))#
apply(mstat,2, function(x) length(x>qchisq(0.95,3)))
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
	H0 <- h0#
H01 <- h0#
h <- 10#
#
H01[["t1"]] <- H01[["t1"]]+ h/sqrt(T)#
H01[["t2"]] <- H01[["t2"]]+ h/sqrt(T)#
H01[["t3"]] <- H01[["t3"]]+ h/sqrt(n)#
#
nsim <- 10#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- NULL#
mstat <- NULL#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
   #
	g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
    	y <- exp(g1-g0)#
 	df <- length(H0)#
	myphi <- function(x) 1-x+x*log(x)#
#
       stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	pvalue <- 1-pchisq(stat, df=df)#
#
       for(i in 1:n.lambda){#
        myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
#
    	 stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	 pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	}#
#
 setTxtProgressBar(pb, sim)#
 mstat <- rbind(mstat, stat)#
 mpval <- rbind(mpval, pvalue)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(x>0.05))#
apply(mstat,2, function(x) length(x>qchisq(0.95,3)))
H01
H0
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
	H0 <- h0#
H01 <- h0#
h <- -.5#
#
H01[["t1"]] <- H01[["t1"]]+ h/sqrt(T)#
H01[["t2"]] <- H01[["t2"]]+ h/sqrt(T)#
H01[["t3"]] <- H01[["t3"]]+ h/sqrt(n)#
#
nsim <- 10#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- NULL#
mstat <- NULL#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
   #
	g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
    	y <- exp(g1-g0)#
 	df <- length(H0)#
	myphi <- function(x) 1-x+x*log(x)#
#
       stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	pvalue <- 1-pchisq(stat, df=df)#
#
       for(i in 1:n.lambda){#
        myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
#
    	 stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	 pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	}#
#
 setTxtProgressBar(pb, sim)#
 mstat <- rbind(mstat, stat)#
 mpval <- rbind(mpval, pvalue)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(x>0.05))#
apply(mstat,2, function(x) length(x>qchisq(0.95,3)))
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
	H0 <- h0#
H01 <- h0#
h <- .1#
#
H01[["t1"]] <- H01[["t1"]]+ h/sqrt(T)#
H01[["t2"]] <- H01[["t2"]]+ h/sqrt(T)#
H01[["t3"]] <- H01[["t3"]]+ h/sqrt(n)#
#
nsim <- 10#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- NULL#
mstat <- NULL#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
   #
	g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
    	y <- exp(g1-g0)#
 	df <- length(H0)#
	myphi <- function(x) 1-x+x*log(x)#
#
       stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	pvalue <- 1-pchisq(stat, df=df)#
#
       for(i in 1:n.lambda){#
        myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
#
    	 stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	 pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	}#
#
 setTxtProgressBar(pb, sim)#
 mstat <- rbind(mstat, stat)#
 mpval <- rbind(mpval, pvalue)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(x>0.05))#
apply(mstat,2, function(x) length(x>qchisq(0.95,3)))
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
	H0 <- h0#
H01 <- h0#
h <- .01#
#
H01[["t1"]] <- H01[["t1"]]+ h/sqrt(T)#
H01[["t2"]] <- H01[["t2"]]+ h/sqrt(T)#
H01[["t3"]] <- H01[["t3"]]+ h/sqrt(n)#
#
nsim <- 10#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- NULL#
mstat <- NULL#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
   #
	g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
    	y <- exp(g1-g0)#
 	df <- length(H0)#
	myphi <- function(x) 1-x+x*log(x)#
#
       stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	pvalue <- 1-pchisq(stat, df=df)#
#
       for(i in 1:n.lambda){#
        myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
#
    	 stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	 pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	}#
#
 setTxtProgressBar(pb, sim)#
 mstat <- rbind(mstat, stat)#
 mpval <- rbind(mpval, pvalue)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(x>0.05))#
apply(mstat,2, function(x) length(x>qchisq(0.95,3)))
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
	H0 <- h0#
H01 <- h0#
h <- .00#
#
H01[["t1"]] <- H01[["t1"]]+ h/sqrt(T)#
H01[["t2"]] <- H01[["t2"]]+ h/sqrt(T)#
H01[["t3"]] <- H01[["t3"]]+ h/sqrt(n)#
#
nsim <- 10#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- NULL#
mstat <- NULL#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
   #
	g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
    	y <- exp(g1-g0)#
 	df <- length(H0)#
	myphi <- function(x) 1-x+x*log(x)#
#
       stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	pvalue <- 1-pchisq(stat, df=df)#
#
       for(i in 1:n.lambda){#
        myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
#
    	 stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	 pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	}#
#
 setTxtProgressBar(pb, sim)#
 mstat <- rbind(mstat, stat)#
 mpval <- rbind(mpval, pvalue)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(x>0.05))#
apply(mstat,2, function(x) length(x>qchisq(0.95,3)))
phi.test(X, H01, H1)
mstat
mpval
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
	H0 <- h0#
H01 <- h0#
h <- 0#
#
H01[["t1"]] <- H01[["t1"]]+ h/sqrt(T)#
H01[["t2"]] <- H01[["t2"]]+ h/sqrt(T)#
H01[["t3"]] <- H01[["t3"]]+ h/sqrt(n)#
#
nsim <- 1#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- NULL#
mstat <- NULL#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
   #
	g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
    	y <- exp(g1-g0)#
 	df <- length(H0)#
	myphi <- function(x) 1-x+x*log(x)#
#
       stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	pvalue <- 1-pchisq(stat, df=df)#
#
       for(i in 1:n.lambda){#
        myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
#
    	 stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	 pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	}#
#
 setTxtProgressBar(pb, sim)#
 mstat <- rbind(mstat, stat)#
 mpval <- rbind(mpval, pvalue)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(x>0.05))#
apply(mstat,2, function(x) length(x>qchisq(0.95,3)))
stat
pval
phi.test(X, H01, H1)
mpval
apply(mpval,2, function(x) length(x<0.05))#
apply(mstat,2, function(x) length(x<qchisq(0.95,3)))
apply(mpval,2, function(x) length(which(x<0.05)))#
apply(mstat,2, function(x) length(x<qchisq(0.95,3)))
apply(mpval,2, function(x) length(which(x<0.05)))#
apply(mstat,2, function(x) length(which(x<qchisq(0.95,3))))
qchisq(0.95,3)
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
	H0 <- h0#
H01 <- h0#
h <- 0#
#
H01[["t1"]] <- H01[["t1"]]+ h/sqrt(T)#
H01[["t2"]] <- H01[["t2"]]+ h/sqrt(T)#
H01[["t3"]] <- H01[["t3"]]+ h/sqrt(n)#
#
nsim <- 100#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- NULL#
mstat <- NULL#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
   #
	g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
    	y <- exp(g1-g0)#
 	df <- length(H0)#
	myphi <- function(x) 1-x+x*log(x)#
#
       stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	pvalue <- 1-pchisq(stat, df=df)#
#
       for(i in 1:n.lambda){#
        myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
#
    	 stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	 pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	}#
#
 setTxtProgressBar(pb, sim)#
 mstat <- rbind(mstat, stat)#
 mpval <- rbind(mpval, pvalue)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(which(x<0.05)))#
apply(mstat,2, function(x) length(which(x>qchisq(0.95,3))))
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
	H0 <- h0#
H01 <- h0#
h <- 0#
#
H01[["t1"]] <- H01[["t1"]]+ h/sqrt(T)#
H01[["t2"]] <- H01[["t2"]]+ h/sqrt(T)#
H01[["t3"]] <- H01[["t3"]]+ h/sqrt(n)#
#
nsim <- 50#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- NULL#
mstat <- NULL#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
   #
	g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
    	y <- exp(g1-g0)#
 	df <- length(H0)#
	myphi <- function(x) 1-x+x*log(x)#
#
       stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	pvalue <- 1-pchisq(stat, df=df)#
#
       for(i in 1:n.lambda){#
        myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
#
    	 stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	 pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	}#
#
 setTxtProgressBar(pb, sim)#
 mstat <- rbind(mstat, stat)#
 mpval <- rbind(mpval, pvalue)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(which(x<0.05)))#
apply(mstat,2, function(x) length(which(x>qchisq(0.95,3))))
apply(mpval,2, function(x) length(which(x<0.05)))/nsim
apply(mstat,2, function(x) length(which(x>qchisq(0.95,3))))/nsim
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
	H0 <- h0#
H01 <- h0#
h <- 0.5#
#
H01[["t1"]] <- H01[["t1"]]+ h/sqrt(T)#
H01[["t2"]] <- H01[["t2"]]+ h/sqrt(T)#
H01[["t3"]] <- H01[["t3"]]+ h/sqrt(n)#
#
nsim <- 50#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- NULL#
mstat <- NULL#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
   #
	g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
    	y <- exp(g1-g0)#
 	df <- length(H0)#
	myphi <- function(x) 1-x+x*log(x)#
#
       stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	pvalue <- 1-pchisq(stat, df=df)#
#
       for(i in 1:n.lambda){#
        myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
#
    	 stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	 pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	}#
#
 setTxtProgressBar(pb, sim)#
 mstat <- rbind(mstat, stat)#
 mpval <- rbind(mpval, pvalue)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(which(x<0.05)))/nsim#
apply(mstat,2, function(x) length(which(x>qchisq(0.95,3))))/nsim
H01
H1
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
	H0 <- h0#
H01 <- h0#
h <- 0.05#
#
H01[["t1"]] <- H01[["t1"]]+ h/sqrt(T)#
H01[["t2"]] <- H01[["t2"]]+ h/sqrt(T)#
H01[["t3"]] <- H01[["t3"]]+ h/sqrt(n)#
#
nsim <- 50#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- NULL#
mstat <- NULL#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
   #
	g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
    	y <- exp(g1-g0)#
 	df <- length(H0)#
	myphi <- function(x) 1-x+x*log(x)#
#
       stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	pvalue <- 1-pchisq(stat, df=df)#
#
       for(i in 1:n.lambda){#
        myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
#
    	 stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	 pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	}#
#
 setTxtProgressBar(pb, sim)#
 mstat <- rbind(mstat, stat)#
 mpval <- rbind(mpval, pvalue)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(which(x<0.05)))/nsim#
apply(mstat,2, function(x) length(which(x>qchisq(0.95,3))))/nsim
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 10#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
mpval <- vector(mode="list")#
mstat <- vector(mode="list")#
H <- c(0, 0.01, 0.05, 0.1, 0.5)#
nh <- length(H)#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[h]] <- rbind(mstat[[h]], stat)#
 	  mpval[[h]] <- rbind(mpval[[h]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(which(x<0.05)))/nsim#
apply(mstat,2, function(x) length(which(x>qchisq(0.95,3))))/nsim
str(mstat)
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 10#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.5)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[h]] <- rbind(mstat[[h]], stat)#
 	  mpval[[h]] <- rbind(mpval[[h]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(which(x<0.05)))/nsim#
apply(mstat,2, function(x) length(which(x>qchisq(0.95,3))))/nsim
mstat
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 10#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.5)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
mstat[[1]] <- NULL#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[h]] <- rbind(mstat[[h]], stat)#
 	  mpval[[h]] <- rbind(mpval[[h]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(which(x<0.05)))/nsim#
apply(mstat,2, function(x) length(which(x>qchisq(0.95,3))))/nsim
mstat
mstat[1]
mstat[[1]]
stat
rbind(mstat[[h]], stat)
rbind(mstat[[j]], stat)
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 10#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.5)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[h]] <- rbind(mstat[[j]], stat)#
 	  mpval[[h]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(which(x<0.05)))/nsim#
apply(mstat,2, function(x) length(which(x>qchisq(0.95,3))))/nsim
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 10#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.5)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
apply(mpval,2, function(x) length(which(x<0.05)))/nsim#
apply(mstat,2, function(x) length(which(x>qchisq(0.95,3))))/nsim
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}
tmp1
tmp2
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 50#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.5)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}
tmp1
tmp2
H
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 50#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}
tmp1
tmp2
rownames(tmp1) <- H
tmp1
rownames(tmp1) <- spritf("h=%.2f",H)
rownames(tmp1) <- sprintf("h=%.2f",H)
tmp1
matplot(tmp1)
matplot(tmp1,type="l")
matplot(H,tmp1,type="l")
matplot(H,tmp2,type="l")
tmp1
tmp2
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 50#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.8, 1, 1.5, 2)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}#
 #
rownames(tmp1) <- sprintf("h=%.2f",H)#
rownames(tmp2) <- sprintf("h=%.2f",H)#
#
tmp1#
tmp2#
#
matplot(H,tmp1,type="l")
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 100#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}#
 #
rownames(tmp1) <- sprintf("h=%.2f",H)#
rownames(tmp2) <- sprintf("h=%.2f",H)#
#
tmp1#
tmp2#
#
matplot(H,tmp1,type="l")
par(mfrow=c(2,1))#
matplot(H,tmp1,type="l")#
matplot(H,tmp1,type="l",ylim=c(0,0.1))
par(mfrow=c(1,2))#
matplot(H,tmp1,type="l")#
matplot(H,tmp1,type="l",ylim=c(0,0.1))
hline(v=0.05)
abline(h=0.05)
par(mfrow=c(1,2))#
matplot(H,tmp1,type="l")#
matplot(H,tmp1,type="l",ylim=c(0,0.1))#
abline(h=0.05, lty=3, col="red")
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 1000#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}#
 #
rownames(tmp1) <- sprintf("h=%.2f",H)#
rownames(tmp2) <- sprintf("h=%.2f",H)#
#
tmp1#
tmp2#
#
par(mfrow=c(1,2))#
matplot(H,tmp1,type="l")#
matplot(H,tmp1,type="l",ylim=c(0,0.1))#
abline(h=0.05, lty=3, col="red")
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 50#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
           stat1 <-  2*sum(y, na.rm=TRUE)#
           pvalue1 <- 1-pchisq(stat1, df=df)#
#
           stat <-  c(stat, stat1)#
           pvalue <- c(pvalue, pvalue1)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}#
 #
rownames(tmp1) <- sprintf("h=%.2f",H)#
rownames(tmp2) <- sprintf("h=%.2f",H)#
#
tmp1#
tmp2#
#
par(mfrow=c(1,2))#
matplot(H,tmp1,type="l")#
matplot(H,tmp1,type="l",ylim=c(0,0.1))#
abline(h=0.05, lty=3, col="red")
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 50#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
           stat1 <-  2*sum(g1-g0, na.rm=TRUE)#
           pvalue1 <- 1-pchisq(stat1, df=df)#
#
           stat <-  c(stat, stat1)#
           pvalue <- c(pvalue, pvalue1)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}#
 #
rownames(tmp1) <- sprintf("h=%.2f",H)#
rownames(tmp2) <- sprintf("h=%.2f",H)#
#
tmp1#
tmp2#
#
par(mfrow=c(1,2))#
matplot(H,tmp1,type="l")#
matplot(H,tmp1,type="l",ylim=c(0,0.1))#
abline(h=0.05, lty=3, col="red")
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 1000#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
           stat1 <-  2*sum(g1-g0, na.rm=TRUE)#
           pvalue1 <- 1-pchisq(stat1, df=df)#
#
           stat <-  c(stat, stat1)#
           pvalue <- c(pvalue, pvalue1)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}#
 #
rownames(tmp1) <- sprintf("h=%.2f",H)#
rownames(tmp2) <- sprintf("h=%.2f",H)#
#
tmp1#
tmp2#
#
par(mfrow=c(1,2))#
matplot(H,tmp1,type="l")#
matplot(H,tmp1,type="l",ylim=c(0,0.1))#
abline(h=0.05, lty=3, col="red")
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3*x")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 100#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
           stat1 <-  2*sum(g1-g0, na.rm=TRUE)#
           pvalue1 <- 1-pchisq(stat1, df=df)#
#
           stat <-  c(stat, stat1)#
           pvalue <- c(pvalue, pvalue1)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}#
 #
rownames(tmp1) <- sprintf("h=%.2f",H)#
rownames(tmp2) <- sprintf("h=%.2f",H)#
#
tmp1#
tmp2#
#
par(mfrow=c(1,2))#
matplot(H,tmp1,type="l")#
matplot(H,tmp1,type="l",ylim=c(0,0.1))#
abline(h=0.05, lty=3, col="red")
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3*x")#
 T<-10#
 n<-1000#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 1000#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
           stat1 <-  2*sum(g1-g0, na.rm=TRUE)#
           pvalue1 <- 1-pchisq(stat1, df=df)#
#
           stat <-  c(stat, stat1)#
           pvalue <- c(pvalue, pvalue1)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}#
 #
rownames(tmp1) <- sprintf("h=%.2f",H)#
rownames(tmp2) <- sprintf("h=%.2f",H)#
#
tmp1#
tmp2#
#
par(mfrow=c(1,2))#
matplot(H,tmp1,type="l")#
matplot(H,tmp1,type="l",ylim=c(0,0.1))#
abline(h=0.05, lty=3, col="red")
100^(1/3)
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3*x")#
 T<-100^(1/3)#
 n<-100#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 100#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
           stat1 <-  2*sum(g1-g0, na.rm=TRUE)#
           pvalue1 <- 1-pchisq(stat1, df=df)#
#
           stat <-  c(stat, stat1)#
           pvalue <- c(pvalue, pvalue1)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}#
 #
rownames(tmp1) <- sprintf("h=%.2f",H)#
rownames(tmp2) <- sprintf("h=%.2f",H)#
#
tmp1#
tmp2#
#
par(mfrow=c(1,2))#
matplot(H,tmp1,type="l")#
matplot(H,tmp1,type="l",ylim=c(0,0.1))#
abline(h=0.05, lty=3, col="red")
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3*x")#
 T<-100^(1/3)#
 n<-100#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(.99, 1.2, 1.5, 1.75, 2, 2.5, 3)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 1000#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
           stat1 <-  2*sum(g1-g0, na.rm=TRUE)#
           pvalue1 <- 1-pchisq(stat1, df=df)#
#
           stat <-  c(stat, stat1)#
           pvalue <- c(pvalue, pvalue1)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}#
 #
rownames(tmp1) <- sprintf("h=%.2f",H)#
rownames(tmp2) <- sprintf("h=%.2f",H)#
#
tmp1#
tmp2#
#
par(mfrow=c(1,2))#
matplot(H,tmp1,type="l")#
matplot(H,tmp1,type="l",ylim=c(0,0.1))#
abline(h=0.05, lty=3, col="red")
 matplot(H,tmp2,type="l")
 matplot(H,tmp2,type="b")
lambda
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3*x")#
 n<-100#
 T<-n^(1/3)#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- c(.99, 3, 10, 20)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 100#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
           stat1 <-  2*sum(g1-g0, na.rm=TRUE)#
           pvalue1 <- 1-pchisq(stat1, df=df)#
#
           stat <-  c(stat, stat1)#
           pvalue <- c(pvalue, pvalue1)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}#
 #
rownames(tmp1) <- sprintf("h=%.2f",H)#
rownames(tmp2) <- sprintf("h=%.2f",H)#
#
tmp1#
tmp2#
#
par(mfrow=c(1,2))#
matplot(H,tmp1,type="l")#
matplot(H,tmp1,type="l",ylim=c(0,0.1))#
abline(h=0.05, lty=3, col="red")
 matplot(H,tmp2,type="b")
colnames(tmp1) <- c("myphi", "GRLT", sprintf("l%.1f", lambda))
tmp2
tmp1
require(yuima)#
#
 model<- setModel(drift="(t1-t2*x)",diffusion="t3*x")#
 n<-100#
 T<-n^(1/3)#
 sampling <- setSampling(Terminal=T,n=n)#
 yuima<-setYuima(model=model, sampling=sampling)#
 h0 <- list(t1=.5, t2=.5, t3=0.25)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- c(.99, 3, 10, 20)#
lambda <- sort(c(-lambda, lambda))#
n.lambda <- length(lambda)#
#
#
#
H0 <- h0#
#
nsim <- 250#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
#
for(sim in 1:nsim){#
 X<-simulate(yuima,xinit=1,true=h0)#
#
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
           stat1 <-  2*sum(g1-g0, na.rm=TRUE)#
           pvalue1 <- 1-pchisq(stat1, df=df)#
#
           stat <-  c(stat, stat1)#
           pvalue <- c(pvalue, pvalue1)#
#
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}#
 #
rownames(tmp1) <- sprintf("h=%.2f",H)#
rownames(tmp2) <- sprintf("h=%.2f",H)#
colnames(tmp1) <- c("myphi", "GRLT", sprintf("l%.1f", lambda))#
colnames(tmp2) <- c("myphi", "GRLT", sprintf("l%.1f", lambda))#
tmp1#
tmp2#
#
par(mfrow=c(1,2))#
matplot(H,tmp1,type="l")#
matplot(H,tmp1,type="l",ylim=c(0,0.1))#
abline(h=0.05, lty=3, col="red")
 matplot(H,tmp2,type="b")
apply(2, mstat, function(x) quantile(x, p=0.95))
ls()
rm(" /Users/jago/Desktop/.Rhistory")
rm("/Users/jago/Desktop/.Rhistory")
rm("~/Desktop/.Rhistory")
ls()
require(yuima)#
#
set.seed(123)#
#
model<- setModel(drift="(t1-t2*x)",diffusion="t3*x")#
n4sim <- 1000#
n4test<-100 #
T<-n4sim^(1/3)#
sampling <- setSampling(Terminal=T,n=n4sim)#
yuima<-setYuima(model=model, sampling=sampling)#
h0 <- list(t1=.5, t2=.5, t3=0.025)#
#
#
alpha <- c(0.1, 0.25, 0.5, 0.75, .9, .99)#
alpha <- sort(c(-alpha,0,alpha))#
n.alpha <- length(alpha)#
lambda <- -c(3, 10, 20)#
lambda <- sort(lambda)#
n.lambda <- length(lambda)#
#
fname <- sprintf("GBM-n%.4d.rda",n4test)#
#
H0 <- h0#
#
nsim <- 100#
#
pb <- txtProgressBar(min = 1, max = nsim, initial = 1, style = 3)#
#
#
H <- c(0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)#
nh <- length(H)#
mpval <- vector(nh,mode="list")#
mstat <- vector(nh,mode="list")#
#
BSdiv <- function(x) ((x-1)/(x+1))^2#
#
for(sim in 1:nsim){#
 X <- simulate(yuima,xinit=1,true=h0)#
 X <- subsampling(X, n=n4test, T=T)#
    #
	H1 <- coef(qmle(X, start=h0, lower=list(t1=0.01, t2=0.01, t3=0.01), upper=list(t1=1.5,t2=1.5,t3=1),method="L-BFGS-B"))#
  #
#
#
#
	d.size <- X@model@equation.number#
	n <- length(X)[1]#
	#
	env <- new.env()#
	assign("X",  as.matrix(yuima:::onezoo(X)), env=env)#
	assign("deltaX",  matrix(0, n-1, d.size), env=env)#
	for(t in 1:(n-1))#
	env$deltaX[t,] <- env$X[t+1,] - env$X[t,]#
	#
	assign("h", deltat(X@data@zoo.data[[1]]), env=env)#
	assign("time", as.numeric(index(X@data@zoo.data[[1]])), env=env) #
	g1 <- yuima:::quasiloglvec(yuima=X, param=H1, print=print, env)#
#
       for(j in 1:nh){   #
	 H01 <- h0#
	 H01[["t1"]] <- H01[["t1"]]+ H[j]/sqrt(T)#
	 H01[["t2"]] <- H01[["t2"]]+ H[j]/sqrt(T)#
	 H01[["t3"]] <- H01[["t3"]]+ H[j]/sqrt(n)#
#
	 g0 <- yuima:::quasiloglvec(yuima=X, param=H01, print=print, env)#
    	 y <- exp(g1-g0)#
 	 df <- length(H0)#
	 myphi <- function(x) 1-x+x*log(x)#
#
        stat <-  2*sum(myphi(y), na.rm=TRUE)#
    	 pvalue <- 1-pchisq(stat, df=df)#
           stat1 <-  2*sum(g1-g0, na.rm=TRUE)#
           pvalue1 <- 1-pchisq(stat1, df=df)#
           stat <-  c(stat, stat1)#
           pvalue <- c(pvalue, pvalue1)#
#
       #
           #         stat2 <-  2*sum(RK2div(y), na.rm=TRUE)#
           #pvalue2 <- 1-pchisq(stat2, df=df)#
           #stat <-  c(stat, stat2)#
           #pvalue <- c(pvalue, pvalue2)#
#
           #stat3 <-  2*sum(PKdiv(y), na.rm=TRUE)#
           #pvalue3 <- 1-pchisq(stat3, df=df)#
           #stat <-  c(stat, stat3)#
           #pvalue <- c(pvalue, pvalue3)#
#
           stat4 <-  2*sum(BSdiv(y), na.rm=TRUE)#
           pvalue4 <- 1-pchisq(stat4, df=df)#
           stat <-  c(stat, stat4)#
           pvalue <- c(pvalue, pvalue4)#
#
           #
        for(i in 1:n.lambda){#
         myphi <- function(x) { (x^(lambda[i]+1) -x - lambda[i]*(x-1))/(lambda[i]*(lambda[i]+1)) }#
    	  stat <- c(stat, 2*sum(myphi(y), na.rm=TRUE))#
    	  pvalue <- c(pvalue, 1-pchisq(stat[i], df=df))#
	 }#
#
	  mstat[[j]] <- rbind(mstat[[j]], stat)#
 	  mpval[[j]] <- rbind(mpval[[j]], pvalue)#
       }#
 setTxtProgressBar(pb, sim)#
#
}#
 close(pb)#
#
tmp1 <- NULL#
tmp2 <- NULL#
#
for(j in 1:nh){   	#
 tmp1 <- rbind(tmp1, apply(mpval[[j]],2, function(x) length(which(x<0.05)))/nsim)#
 tmp2 <- rbind(tmp2, apply(mstat[[j]],2, function(x) length(which(x>qchisq(0.95,3))))/nsim)#
}#
 #
rownames(tmp1) <- sprintf("h=%.2f",H)#
rownames(tmp2) <- sprintf("h=%.2f",H)#
colnames(tmp1) <- c("myphi", "GRLT", "BSdiv", sprintf("l%.1f", lambda))#
colnames(tmp2) <- c("myphi", "GRLT", "BSdiv", sprintf("l%.1f", lambda))#
tmp1#
tmp2#
#
#par(mfrow=c(1,2))#
#matplot(H,tmp1,type="l")#
#matplot(H,tmp1,type="l",ylim=c(0,0.1))#
#abline(h=0.05, lty=3, col="red")#
#
#
tmp3 <- numeric(NCOL(mstat[[1]]))#
#
for(i in 1:NCOL(mstat[[1]]))#
        tmp3[i] <- quantile( mstat[[1]][,i], p=0.95)#
#
#
tmp4 <- matrix(,nh,NCOL(mstat[[1]]))#
#
#
for(j in 1:nh){   	#
    for(i in 1:NCOL(mstat[[j]])){#
        tmp4[j,i] <- length(which( mstat[[j]][,i] > tmp3[i] ))/nsim#
    }#
}#
rownames(tmp4) <- sprintf("h=%.2f",H)#
colnames(tmp4) <- c("myphi", "GRLT",  "BSdiv", sprintf("l%.1f", lambda))#
#
matplot(H,tmp4,type="b")#
#
save.image(file=fname)
                                                                        #
YUIMA: 'delta' (re)defined.#
  |=====                                                                                       |   5%#
YUIMA: 'delta' (re)defined.#
  |======                                                                                      |   6%#
YUIMA: 'delta' (re)defined.#
  |=======                                                                                     |   8%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |=========                                                                                   |  10%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |==========                                                                                  |  11%#
YUIMA: 'delta' (re)defined.#
  |=============                                                                               |  14%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |===============                                                                             |  16%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |================                                                                            |  17%#
YUIMA: 'delta' (re)defined.#
  |==================                                                                          |  19%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |====================                                                                        |  21%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |====================                                                                        |  22%#
YUIMA: 'delta' (re)defined.#
  |======================                                                                      |  24%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |=======================                                                                     |  25%#
YUIMA: 'delta' (re)defined.#
  |=========================                                                                   |  27%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |==========================                                                                  |  28%#
YUIMA: 'delta' (re)defined.#
  |===========================                                                                 |  29%#
YUIMA: 'delta' (re)defined.#
  |============================                                                                |  30%#
YUIMA: 'delta' (re)defined.#
  |===============================                                                             |  33%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |================================                                                            |  34%#
YUIMA: 'delta' (re)defined.#
  |=================================                                                           |  35%#
YUIMA: 'delta' (re)defined.#
  |======================================                                                      |  41%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |=========================================                                                   |  44%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |==========================================                                                  |  45%#
YUIMA: 'delta' (re)defined.#
  |============================================                                                |  47%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |=============================================                                               |  48%#
YUIMA: 'delta' (re)defined.#
  |==============================================                                              |  49%#
YUIMA: 'delta' (re)defined.#
  |===============================================                                             |  52%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |================================================                                            |  53%#
YUIMA: 'delta' (re)defined.#
  |=================================================                                           |  54%#
YUIMA: 'delta' (re)defined.#
  |==================================================                                          |  55%#
YUIMA: 'delta' (re)defined.#
  |====================================================                                        |  57%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |======================================================                                      |  59%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |=======================================================                                     |  60%#
YUIMA: 'delta' (re)defined.#
  |========================================================                                    |  61%#
YUIMA: 'delta' (re)defined.#
  |==========================================================                                  |  63%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |===========================================================                                 |  65%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |============================================================                                |  66%#
YUIMA: 'delta' (re)defined.#
  |===============================================================                             |  69%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |==================================================================                          |  72%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |====================================================================                        |  74%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |=====================================================================                       |  75%#
YUIMA: 'delta' (re)defined.#
  |=======================================================================                     |  77%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |========================================================================                    |  78%#
YUIMA: 'delta' (re)defined.#
  |=========================================================================                   |  80%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |==========================================================================                  |  81%#
YUIMA: 'delta' (re)defined.#
  |============================================================================                |  83%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |==============================================================================              |  85%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |===============================================================================             |  86%#
YUIMA: 'delta' (re)defined.#
  |==================================================================================          |  89%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |====================================================================================        |  91%  |                                                                                                  #
YUIMA: 'delta' (re)defined.#
  |=====================================================================================       |  92%#
YUIMA: 'delta' (re)defined.#
  |======================================================================================      |  94%  |
 X <- simulate(yuima,xinit=1,true=h0)
X <- (subsampling(X, n=n4test, T=T))
X <- try(subsampling(X, n=n4test, T=T))
X <- try(subsampling(X, n=n4test, T=T),silent="TRUE")
X <- .(subsampling(X, n=n4test, T=T))
X <- (subsampling(X, n=n4test, T=T))
 X <- simulate(yuima,xinit=1,true=h0, subsampling=setSampling(n=n4test, T=T))
plot(X)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/OU-n0100.rda")
matplot(H,tmp4,type="b")
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/GBM-n0500.rda")
matplot(H,tmp4,type="b")
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/GBM-n0250.rda")
matplot(H,tmp4,type="b")
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/GBM-n0100.rda")
matplot(H,tmp4,type="b")
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/GBM-n0050.rda")
matplot(H,tmp4,type="b")
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n0050.rda")
tmp4
matplot(H, tmp4, type="b")
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n0100.rda")
matplot(H, tmp4, type="b")
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n0250.rda")
matplot(H, tmp4, type="b")
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n0500.rda")
matplot(H, tmp4, type="b")
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n1000.rda")
matplot(H, tmp4, type="b")
tmp4
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/OU-n0050.rda")
matplot(H, tmp4, type="b")
tmp4
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/OU-n0100.rda")
tmp4
matplot(H, tmp4, type="b")
toLatex(tmp4)
library(xtable)
xtable(tmp4)
n4test
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/OU-n0050.rda")
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/OU-n0250.rda")
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/OU-n0500.rda")
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/OU-n1000.rda")
tmp4
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/GBM-n0050.rda")
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/GBM-n0100.rda")
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/GBM-n0250.rda")
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/GBM-n0500.rda")
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/GBM-n1000.rda")
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n0050.rda")
tmp4
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n0100.rda")
tmp4
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n0200.rda")
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n0250.rda")
tmp4
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n0500.rda")
tmp4
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n1000.rda")
tmp4
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n0050.rda")
tmp4
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n0050.rda")
tmp4
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n0100.rda")
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n0250.rda")
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n0500.rda")
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/CIR-n1000.rda")
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/MGBM-n0050.rda")
xtable(tmp4)
load("/Users/jago/Documents/Stex/riviste/phi-div-new/R/MGBM-n0100.rda")
xtable(tmp4)
require(fImport)#
X <- yahooSeries("GOOG")
str(X)
data(X)
X[,"GOOG.Close"]
library(foreign)#
#
x <- read.dta("basic.dta")#
#
# Table 1 in Ebonya#
# Indep. vars#
# anygirls: Any female children#
# ngirls: Number of female children#
# totchi: Total number of children#
#
# white: White=1, 0 otherwise#
# female: Female=1, 0 otherwise#
# age: age#
# srvlng: Service length (years)#
# rgroup: 0=None, 1=Protestant, 2=Catholic, 3=Other Christian, 4=Other religion#
#
# demvote : Democratic vote share#
#
# Dependent variables#
# nowtot: NOW score#
# aaw: AAUW score#
# rtl: supposed to be "NRLC score", but summary is totally different#
#
# Other vars#
# party: Democrats=1, Republicans=2#
#
# equation (2) I guess is#
#
x$party <- factor(x$party)#
levels(x$party) <- c("Democrats", "Republicans", "Other")#
x$race <- factor(x$white)#
levels(x$race) <- c("Other","White")#
x$white <- NULL#
#
x$gender<- factor(x$female)#
levels(x$gender) <- c("Male","Female")#
x$female <- NULL#
#
idx0 <- which(x$rgroup==0)#
idx1 <- which(x$rgroup==1)#
x$rgroup[idx1] <- 0#
x$rgroup[idx0] <- 1#
x$rgroup <- factor(x$rgroup)#
levels(x$rgroup) <- c("Protestant", "None", "Catholic", "Other Christian", "Other religion")#
#
require(memisc)#
#
#
x$hasGirls <- x$ngirls>0#
#
tot105 <- subset(x, congress==105)#
#
require(cem)#
#
mvars <- c("gender", "race", "srvlng", "age","demvote", "repub") #
tvar <- "hasGirls"#
#
#
basemod <- lm(nowtot ~ ngirls + factor(totchi)+gender + race + repub + srvlng + region+I(srvlng^2) + age + I(age^2) + rgroup + demvote, data=tot105)#
#
l1vars <- c(mvars, "region", "rgroup")#
gr <- list(rgroup=list("None", c("Catholic", "Other Christian", "Protestant"), "Other religion"))#
gr <- NULL#
set.seed(123)#
imb0 <- L1.profile(tot105$hasGirls,tot105[,c("hasGirls", l1vars)], drop=c("hasGirls"),M=500, grouping=gr)#
#
tmp <- L1.meas(tot105$hasGirls, tot105[,c("hasGirls", l1vars)], drop=c("hasGirls"), breaks=imb0$medianCP, grouping=gr)#
L1 <- tmp$L1#
LCS <- tmp$LCS#
mt <- sum(tot105$hasGirls==TRUE,na.rm=TRUE)#
mc <- sum(tot105$hasGirls==FALSE,na.rm=TRUE)
library(foreign)#
#
x <- read.dta("basic.dta")#
#
# Table 1 in Ebonya#
# Indep. vars#
# anygirls: Any female children#
# ngirls: Number of female children#
# totchi: Total number of children#
#
# white: White=1, 0 otherwise#
# female: Female=1, 0 otherwise#
# age: age#
# srvlng: Service length (years)#
# rgroup: 0=None, 1=Protestant, 2=Catholic, 3=Other Christian, 4=Other religion#
#
# demvote : Democratic vote share#
#
# Dependent variables#
# nowtot: NOW score#
# aaw: AAUW score#
# rtl: supposed to be "NRLC score", but summary is totally different#
#
# Other vars#
# party: Democrats=1, Republicans=2#
#
# equation (2) I guess is#
#
x$party <- factor(x$party)#
levels(x$party) <- c("Democrats", "Republicans", "Other")#
x$race <- factor(x$white)#
levels(x$race) <- c("Other","White")#
x$white <- NULL#
#
x$gender<- factor(x$female)#
levels(x$gender) <- c("Male","Female")#
x$female <- NULL#
#
idx0 <- which(x$rgroup==0)#
idx1 <- which(x$rgroup==1)#
x$rgroup[idx1] <- 0#
x$rgroup[idx0] <- 1#
x$rgroup <- factor(x$rgroup)#
levels(x$rgroup) <- c("Protestant", "None", "Catholic", "Other Christian", "Other religion")#
#
require(memisc)#
#
#
x$hasGirls <- x$ngirls>0#
#
tot105 <- subset(x, congress==105)#
#
require(cem)#
#
mvars <- c("gender", "race", "srvlng", "age","demvote", "repub") #
tvar <- "hasGirls"
setwd("/Users/jago/Documents/Stex/riviste/cegg/pubs/JASA/R-replication")
library(foreign)#
#
x <- read.dta("basic.dta")#
#
# Table 1 in Ebonya#
# Indep. vars#
# anygirls: Any female children#
# ngirls: Number of female children#
# totchi: Total number of children#
#
# white: White=1, 0 otherwise#
# female: Female=1, 0 otherwise#
# age: age#
# srvlng: Service length (years)#
# rgroup: 0=None, 1=Protestant, 2=Catholic, 3=Other Christian, 4=Other religion#
#
# demvote : Democratic vote share#
#
# Dependent variables#
# nowtot: NOW score#
# aaw: AAUW score#
# rtl: supposed to be "NRLC score", but summary is totally different#
#
# Other vars#
# party: Democrats=1, Republicans=2#
#
# equation (2) I guess is#
#
x$party <- factor(x$party)#
levels(x$party) <- c("Democrats", "Republicans", "Other")#
x$race <- factor(x$white)#
levels(x$race) <- c("Other","White")#
x$white <- NULL#
#
x$gender<- factor(x$female)#
levels(x$gender) <- c("Male","Female")#
x$female <- NULL#
#
idx0 <- which(x$rgroup==0)#
idx1 <- which(x$rgroup==1)#
x$rgroup[idx1] <- 0#
x$rgroup[idx0] <- 1#
x$rgroup <- factor(x$rgroup)#
levels(x$rgroup) <- c("Protestant", "None", "Catholic", "Other Christian", "Other religion")#
#
require(memisc)#
#
#
x$hasGirls <- x$ngirls>0#
#
tot105 <- subset(x, congress==105)#
#
require(cem)#
#
mvars <- c("gender", "race", "srvlng", "age","demvote", "repub") #
tvar <- "hasGirls"
#
basemod <- lm(nowtot ~ ngirls + factor(totchi)+gender + race + repub + srvlng + region+I(srvlng^2) + age + I(age^2) + rgroup + demvote, data=tot105)#
#
l1vars <- c(mvars, "region", "rgroup")#
gr <- list(rgroup=list("None", c("Catholic", "Other Christian", "Protestant"), "Other religion"))#
gr <- NULL#
set.seed(123)#
imb0 <- L1.profile(tot105$hasGirls,tot105[,c("hasGirls", l1vars)], drop=c("hasGirls"),M=500, grouping=gr)#
#
tmp <- L1.meas(tot105$hasGirls, tot105[,c("hasGirls", l1vars)], drop=c("hasGirls"), breaks=imb0$medianCP, grouping=gr)#
L1 <- tmp$L1#
LCS <- tmp$LCS#
mt <- sum(tot105$hasGirls==TRUE,na.rm=TRUE)#
mc <- sum(tot105$hasGirls==FALSE,na.rm=TRUE)
#
#
imb <- imbalance(tot105$hasGirls, tot105[,c("hasGirls", l1vars)], drop=c("hasGirls"), breaks=imb0$medianCP, grouping=imb0$medianGR)#
#
#
mod <- lm(nowtot ~ ngirls + factor(totchi)+gender + race + repub + srvlng + region+I(srvlng^2) + age + I(age^2) + rgroup + demvote, data=tot105)	#
#
idx.min <- which.min(ans[,"L1"])#
mymat1 <- cem(tvar, data=tot105[c(tvar,mvars)], cutpoints=newcuts[[idx.min]], eval.imb=FALSE)#
imb1 <- imbalance(tot105$hasGirls, tot105[,c("hasGirls", l1vars)], drop=c("hasGirls"), breaks=imb0$medianCP, weights=mymat1$w, grouping=imb0$medianGR)#
mod1 <- lm(nowtot ~ ngirls + factor(totchi)+gender + race + repub + srvlng + region+I(srvlng^2) + age + I(age^2) + rgroup + demvote, data=tot105, weights= mymat1$w)	#
#
idx.min <- which.min(ans[,"n"])#
mymat2 <- cem(tvar, data=tot105[c(tvar,mvars)], cutpoints=newcuts[[idx.min]], eval.imb=FALSE)#
imb2 <- imbalance(tot105$hasGirls, tot105[,c("hasGirls", l1vars)], drop=c("hasGirls"), breaks=imb0$medianCP, weights=mymat2$w, grouping=imb0$medianGR)#
mod2 <- lm(nowtot ~ ngirls + factor(totchi)+gender + race + repub + srvlng + region+I(srvlng^2) + age + I(age^2) + rgroup + demvote, data=tot105, weights= mymat2$w)	#
#
bigmod <- mtable(mod, mod1, mod2, summary.stats=c("R-squared","adj. R-squared","Log-likelihood", "AIC", "N"))#
#
bigmod
#
#
m <- 1#
qoi <- summary(basemod)$coefficients["ngirls",]#
cuts <- vector(mode="list")#
cuts[[m]] <- "NONE"#
for(i in 3:11){#
 for(j in 3:11){#
  for(k in 3:11){#
	m <- m +1#
 	cuts[[m]] <- list(srvlng=i, demvote=j, age=k)#
	mymat <- cem(tvar, data=tot105[c(tvar,mvars)], cutpoints=cuts[[m]], eval.imb=FALSE)#
    mt <- c(mt, mymat$tab["Matched", "GTRUE"])#
    mc <- c(mc, mymat$tab["Matched", "GFALSE"])#
	mymod <- lm(nowtot ~ ngirls + factor(totchi)+gender + race + repub + srvlng + region+I(srvlng^2) + age + I(age^2) + rgroup + demvote, data=tot105, weights= mymat$w)	#
    qoi <- cbind(qoi, summary(mymod)$coefficients["ngirls",])#
	tmp <- L1.meas(tot105$hasGirls, tot105[,c("hasGirls", l1vars)], drop=c("hasGirls"), breaks=imb0$medianCP, weights=mymat$w, grouping=imb0$medianGR)#
	L1 <- c(L1, tmp$L1)#
	LCS <- c(LCS, tmp$LCS)#
	cat(".")#
}}}#
ssize <- mt+mc
#
res <- cbind(ssize, qoi["Estimate",], qoi["Estimate",]-qoi["Std. Error",], qoi["Estimate",]+qoi["Std. Error",], L1)#
colnames(res) <- c("n", "att", "low", "upp", "L1")#
rownames(res) <- NULL#
#
ans <- res[order(res[,"n"], decreasing=TRUE),]#
newcuts <- cuts[ order(res[,"n"], decreasing=TRUE) ]#
#
require(arules)#
#
duplicated(ans) -> idx2#
ans <- ans[which(idx2==FALSE),]#
#
newcuts <- newcuts[ which(idx2==FALSE) ]#
#
#pdf(file="att_plot.pdf", width=9, height=5)#
par(mar=c(4,4,0.3,0.3))#
plot(ans[,"n"], ans[,"att"], type="b", ylim=c(0,7), xlab="sample size", ylab="treatment effect",lty=3,cex=0.5,col="red")#
abline(lm(ans[,"att"] ~ ans[,"n"]), lty=2,col="blue")#
text(ans[,"n"], ans[,"att"], adj = -0.35, labels = sprintf("%3.2f", ans[,"L1"]), srt = -45, cex = 0.5)#
#dev.off()
#
#
#
imb <- imbalance(tot105$hasGirls, tot105[,c("hasGirls", l1vars)], drop=c("hasGirls"), breaks=imb0$medianCP, grouping=imb0$medianGR)#
#
#
mod <- lm(nowtot ~ ngirls + factor(totchi)+gender + race + repub + srvlng + region+I(srvlng^2) + age + I(age^2) + rgroup + demvote, data=tot105)	#
#
idx.min <- which.min(ans[,"L1"])#
mymat1 <- cem(tvar, data=tot105[c(tvar,mvars)], cutpoints=newcuts[[idx.min]], eval.imb=FALSE)#
imb1 <- imbalance(tot105$hasGirls, tot105[,c("hasGirls", l1vars)], drop=c("hasGirls"), breaks=imb0$medianCP, weights=mymat1$w, grouping=imb0$medianGR)#
mod1 <- lm(nowtot ~ ngirls + factor(totchi)+gender + race + repub + srvlng + region+I(srvlng^2) + age + I(age^2) + rgroup + demvote, data=tot105, weights= mymat1$w)	#
#
idx.min <- which.min(ans[,"n"])#
mymat2 <- cem(tvar, data=tot105[c(tvar,mvars)], cutpoints=newcuts[[idx.min]], eval.imb=FALSE)#
imb2 <- imbalance(tot105$hasGirls, tot105[,c("hasGirls", l1vars)], drop=c("hasGirls"), breaks=imb0$medianCP, weights=mymat2$w, grouping=imb0$medianGR)#
mod2 <- lm(nowtot ~ ngirls + factor(totchi)+gender + race + repub + srvlng + region+I(srvlng^2) + age + I(age^2) + rgroup + demvote, data=tot105, weights= mymat2$w)	#
#
bigmod <- mtable(mod, mod1, mod2, summary.stats=c("R-squared","adj. R-squared","Log-likelihood", "AIC", "N"))#
#
bigmod
#
bigmod$summaries -> tab#
tab <- rbind(tab, round(c(imb$L1$L1, imb1$L1$L1, imb2$L1$L1),3))#
nr <- NROW(tab)#
rownames(tab)[nr] <- "L1"#
tab <- tab[c(1:(nr-2), nr, nr-1),]#
bigmod$summaries <- tab#
#
### totchi no factor#
#
mod <- lm(nowtot ~ ngirls + totchi+gender + race + repub + srvlng + region+I(srvlng^2) + age + I(age^2) + rgroup + demvote, data=tot105)	#
#
idx.min <- which.min(ans[,"L1"])#
mymat1 <- cem(tvar, data=tot105[c(tvar,mvars)], cutpoints=newcuts[[idx.min]], eval.imb=FALSE)#
imb1 <- imbalance(tot105$hasGirls, tot105[,c("hasGirls", l1vars)], drop=c("hasGirls"), breaks=imb0$medianCP, weights=mymat1$w, grouping=imb0$medianGR)#
mod1 <- lm(nowtot ~ ngirls + totchi+gender + race + repub + srvlng + region+I(srvlng^2) + age + I(age^2) + rgroup + demvote, data=tot105, weights= mymat1$w)	#
#
idx.min <- which.min(ans[,"n"])#
mymat2 <- cem(tvar, data=tot105[c(tvar,mvars)], cutpoints=newcuts[[idx.min]], eval.imb=FALSE)#
imb2 <- imbalance(tot105$hasGirls, tot105[,c("hasGirls", l1vars)], drop=c("hasGirls"), breaks=imb0$medianCP, weights=mymat2$w, grouping=imb0$medianGR)#
mod2 <- lm(nowtot ~ ngirls + totchi+gender + race + repub + srvlng + region+I(srvlng^2) + age + I(age^2) + rgroup + demvote, data=tot105, weights= mymat2$w)	#
#
bigmod0 <- mtable(mod, mod2, summary.stats=c("R-squared","adj. R-squared","Log-likelihood", "AIC", "N"))#
#
bigmod0
bigmod0$summaries -> tab#
tab <- rbind(tab, round(c(imb$L1$L1, imb2$L1$L1),3))#
nr <- NROW(tab)#
rownames(tab)[nr] <- "L1"#
tab <- tab[c(1:(nr-2), nr, nr-1),]#
bigmod0$summaries <- tab#
#
aa <- relabel(bigmod0, "I(age^2)"="age squared", "I(srvlng^2)"="srvlng squared", #
"ngirls" = "number of girls", "totchi" = "total number of children",#
"repub" = "republican party", "demvote"="percentage of democrat votes")#
bb <- relabel(aa, "srvlng"="service length", "rgroup"="religion group", "region"="region:", gsub=TRUE)
#
source("modelDep.R")#
#
#
mdep0 <- modelDep( nowtot ~ ngirls + totchi+gender + race + repub + srvlng + region+ + age + rgroup + demvote, data=tot105, tevar="ngirls")#
mdep1 <- modelDep( nowtot ~ ngirls + totchi+gender + race + repub + srvlng + region+ + age + rgroup + demvote, data=tot105, tevar="ngirls",weights=mymat1$w)#
mdep2 <- modelDep( nowtot ~ ngirls + totchi+gender + race + repub + srvlng + region+ + age + rgroup + demvote, data=tot105, tevar="ngirls",weights=mymat2$w)#
#
summary(mdep0$TE)#
summary(mdep1$TE)#
summary(mdep2$TE)
#
round(range(mdep0$TE,na.rm=TRUE),3)#
round(range(mdep2$TE,na.rm=TRUE),3)#
#
par(mfrow=c(3,1))#
#
plot(density(mdep0$TE, na.rm=TRUE), xlim=c(-4, 10),  main=sprintf("raw data, L1=%.3f, n=%d",imb$L1$L1,sum(summary(mod)$df[1:2])),xlab="TE estimate")#
abline(v=summary(mod)$coef["ngirls","Estimate"],lty=3)#
plot(density(mdep1$TE, na.rm=TRUE), xlim=c(-4, 10), main=sprintf("min L1, L1=%.3f, n=%d",imb1$L1$L1,sum(summary(mod1)$df[1:2])),xlab="TE estimate")#
abline(v=summary(mod1)$coef["ngirls","Estimate"],lty=3)#
plot(density(mdep2$TE, na.rm=TRUE), xlim=c(-4, 10), main=sprintf("min n, L1=%.3f, n=%d",imb2$L1$L1,sum(summary(mod2)$df[1:2])),xlab="TE estimate")#
abline(v=summary(mod2)$coef["ngirls","Estimate"],lty=3)
par(mar=c(2.5,2.5,.5,.5))#
plot(density(mdep0$TE, na.rm=TRUE), xlim=c(min(mdep0$TE,na.rm=TRUE), max(mdep0$TE,na.rm=TRUE)),  #
main="",xlab="TE estimate",ylim=c(0,1.8))#
abline(v=summary(mod)$coef["ngirls","Estimate"],lty=3)#
lines(density(mdep2$TE, na.rm=TRUE),  lty=2, col="red")#
abline(v=summary(mod2)$coef["ngirls","Estimate"],lty=3, col="red")#
#
text(1.5,0.5, "raw data")#
text(4.8,0.5, "matched data")
#
#
#
require(gdata)#
tot105BIS <- tot105#
tot105BIS$gender <- as.numeric(tot105$gender)#
tot105BIS$repub <- 2-as.numeric(tot105$repub)#
tot105BIS$race <- 2-as.numeric(tot105$race)#
tot105BIS$rgroup <- reorder(tot105$rgroup, new.order=c(1,5,4,2,3))#
tot105BIS$rgroup <- as.numeric(tot105BIS$rgroup)
#
idx <- which(tot105$hasGirls)#
tot105BIS$gender[idx] <- tot105BIS$gender[idx]+rnorm(length(idx),0,.01)#
tot105BIS$repub[idx] <- tot105BIS$repub[idx]+rnorm(length(idx),0,.01)#
tot105BIS$race[idx] <- tot105BIS$race[idx]+rnorm(length(idx),0,.01)#
tot105BIS$rgroup[idx] <- tot105BIS$rgroup[idx]+rnorm(length(idx),0,.01)#
tot105BIS$age[idx] <- tot105BIS$age[idx]+rnorm(length(idx),0,.01)#
tot105BIS$demvote[idx] <- tot105BIS$demvote[idx]+rnorm(length(idx),0,.01)
#
nm <- colnames(tot105BIS)#
idx <- which(nm=="repub")#
nm[idx] <- "PartyID"#
idx <- which(nm=="demvote")#
nm[idx] <- "DemVote"#
idx <- which(nm=="rgroup")#
nm[idx] <- "Religion"#
idx <- which(nm=="age")#
nm[idx] <- "Age"#
idx <- which(nm=="seniority")#
nm[idx] <- "Seniority"#
idx <- which(nm=="gender")#
nm[idx] <- "Gender"#
idx <- which(nm=="race")#
nm[idx] <- "Race"#
#
pvars1 <- c("Gender", "Race", "Seniority", "Age", "DemVote", "PartyID", "Religion")#
colnames(tot105BIS) <- nm
#
parallel( ~tot105BIS[which( tot105BIS$hasGirls), pvars1], group= mymat2$w[which( tot105BIS$hasGirls)]>0,#
 alpha=c(0.05,0.2),  col=c("red","blue"),horizontal.axis=FALSE,scales = list(x = list(rot = 90)))
pvars1
#
#
vvars <- c("gender",  "race",    "seniority",  "age" ,    "demvote" ,"repub"  , "region" , "rgroup" )#
#
d0 <- tot105[which( tot105$hasGirls), vvars]#
#
d2 <- tot105[which( tot105$hasGirls& mymat2$w>0), vvars]#
#
d3 <- tot105[which( tot105$hasGirls& mymat2$w==0), vvars]#
#
r1 <- c(prop.table(table(d0$gender))["Male"], prop.table(table(d2$gender))["Male"],  prop.table(table(d3$gender))["Male"])#
r2 <- c(mean(d0$seniority,na.rm=TRUE), mean(d2$seniority,na.rm=TRUE),  mean(d3$seniority,na.rm=TRUE))#
r3 <- c(mean(d0$age,na.rm=TRUE), mean(d2$age,na.rm=TRUE),  mean(d3$age,na.rm=TRUE))#
r4 <- c(mean(d0$demvote,na.rm=TRUE), mean(d2$demvote,na.rm=TRUE), mean(d3$demvote,na.rm=TRUE))#
r5 <- c(mean(d0$repub,na.rm=TRUE), mean(d2$repub,na.rm=TRUE),  mean(d3$repub,na.rm=TRUE))#
r6 <- c(prop.table(table(d0$race))["White"], prop.table(table(d2$race))["White"], prop.table(table(d3$race))["White"])#
r7 <- cbind(prop.table(table(d0$rgroup)), prop.table(table(d2$rgroup)), prop.table(table(d3$rgroup)))#
#
comptab <- rbind(r1, r2,r3,r4,r5,r6,r7)#
rownames(comptab) <- c("gender (% males)", "service length (years)", #
"age (years)", "dem. vote (%)", #
"republican (%)", #
"race (% white)", #
"religion: protestant (%)", "religion: none (%)", "religion: catholic (%)", #
"religion: other christian (%)", "religion: other (%)")#
colnames(comptab) <- c("raw data", "matched data", "unmatched data")#
#
tmptab <- comptab#
tmptab[8:7,] <- comptab[7:8,]#
rownames(tmptab)[8:7] <- rownames(comptab)[7:8]
names(tot105BIS)
pvars1
sort(pvars1)
sort(names(tot105BIS))
sort(names(tot105))
tot105BIS <- tot105#
tot105BIS$gender <- as.numeric(tot105$gender)#
tot105BIS$repub <- 2-as.numeric(tot105$repub)#
tot105BIS$race <- 2-as.numeric(tot105$race)#
tot105BIS$rgroup <- reorder(tot105$rgroup, new.order=c(1,5,4,2,3))#
tot105BIS$rgroup <- as.numeric(tot105BIS$rgroup)
sort(names(tot105BIS))
idx <- which(tot105$hasGirls)#
tot105BIS$gender[idx] <- tot105BIS$gender[idx]+rnorm(length(idx),0,.01)#
tot105BIS$repub[idx] <- tot105BIS$repub[idx]+rnorm(length(idx),0,.01)#
tot105BIS$race[idx] <- tot105BIS$race[idx]+rnorm(length(idx),0,.01)#
tot105BIS$rgroup[idx] <- tot105BIS$rgroup[idx]+rnorm(length(idx),0,.01)#
tot105BIS$age[idx] <- tot105BIS$age[idx]+rnorm(length(idx),0,.01)#
tot105BIS$demvote[idx] <- tot105BIS$demvote[idx]+rnorm(length(idx),0,.01)
#
#
nm <- colnames(tot105BIS)#
idx <- which(nm=="repub")#
nm[idx] <- "PartyID"#
idx <- which(nm=="demvote")#
nm[idx] <- "DemVote"#
idx <- which(nm=="rgroup")#
nm[idx] <- "Religion"#
idx <- which(nm=="age")#
nm[idx] <- "Age"#
idx <- which(nm=="seniority")#
nm[idx] <- "Seniority"#
idx <- which(nm=="gender")#
nm[idx] <- "Gender"#
idx <- which(nm=="race")#
nm[idx] <- "Race"
sort(names(tot105BIS))
nm
sort(nm)
tot105BIS <- tot105#
tot105BIS$gender <- as.numeric(tot105$gender)#
tot105BIS$repub <- 2-as.numeric(tot105$repub)#
tot105BIS$race <- 2-as.numeric(tot105$race)#
tot105BIS$rgroup <- reorder(tot105$rgroup, new.order=c(1,5,4,2,3))#
tot105BIS$rgroup <- as.numeric(tot105BIS$rgroup)
idx <- which(tot105$hasGirls)#
tot105BIS$gender[idx] <- tot105BIS$gender[idx]+rnorm(length(idx),0,.01)#
tot105BIS$repub[idx] <- tot105BIS$repub[idx]+rnorm(length(idx),0,.01)#
tot105BIS$race[idx] <- tot105BIS$race[idx]+rnorm(length(idx),0,.01)#
tot105BIS$rgroup[idx] <- tot105BIS$rgroup[idx]+rnorm(length(idx),0,.01)#
tot105BIS$age[idx] <- tot105BIS$age[idx]+rnorm(length(idx),0,.01)#
tot105BIS$demvote[idx] <- tot105BIS$demvote[idx]+rnorm(length(idx),0,.01)
sort(names(tot105BIS))
nm <- colnames(tot105BIS)
sort(nm)
idx <- which(nm=="repub")
id
idx
nm[idx] <- "PartyID"#
idx <- which(nm=="demvote")#
nm[idx] <- "DemVote"#
idx <- which(nm=="rgroup")#
nm[idx] <- "Religion"#
idx <- which(nm=="age")#
nm[idx] <- "Age"#
idx <- which(nm=="seniority")#
nm[idx] <- "Seniority"#
idx <- which(nm=="gender")#
nm[idx] <- "Gender"#
idx <- which(nm=="race")#
nm[idx] <- "Race"
nm
pvars1 <- c("Gender", "Race", "Seniority", "Age", "DemVote", "PartyID", "Religion")#
colnames(tot105BIS) <- nm
sort(names(tot105BIS))
parallel( ~tot105BIS[which( tot105BIS$hasGirls), pvars1], group= mymat2$w[which( tot105BIS$hasGirls)]>0,#
 alpha=c(0.05,0.2),  col=c("red","blue"),horizontal.axis=FALSE,scales = list(x = list(rot = 90)))
pvars1
names(tot105BIS)
sort(names(tot105BIS))
sort(pvars1)
sort(colnames(tot105))
#
#
#
require(gdata)#
tot105BIS <- tot105#
tot105BIS$gender <- as.numeric(tot105$gender)#
tot105BIS$repub <- 2-as.numeric(tot105$repub)#
tot105BIS$race <- 2-as.numeric(tot105$race)#
tot105BIS$rgroup <- reorder(tot105$rgroup, new.order=c(1,5,4,2,3))#
tot105BIS$rgroup <- as.numeric(tot105BIS$rgroup)#
#
#
idx <- which(tot105$hasGirls)#
tot105BIS$gender[idx] <- tot105BIS$gender[idx]+rnorm(length(idx),0,.01)#
tot105BIS$repub[idx] <- tot105BIS$repub[idx]+rnorm(length(idx),0,.01)#
tot105BIS$race[idx] <- tot105BIS$race[idx]+rnorm(length(idx),0,.01)#
tot105BIS$rgroup[idx] <- tot105BIS$rgroup[idx]+rnorm(length(idx),0,.01)#
tot105BIS$age[idx] <- tot105BIS$age[idx]+rnorm(length(idx),0,.01)#
tot105BIS$demvote[idx] <- tot105BIS$demvote[idx]+rnorm(length(idx),0,.01)#
 #
#
nm <- colnames(tot105BIS)#
idx <- which(nm=="repub")#
nm[idx] <- "PartyID"#
idx <- which(nm=="demvote")#
nm[idx] <- "DemVote"#
idx <- which(nm=="rgroup")#
nm[idx] <- "Religion"#
idx <- which(nm=="age")#
nm[idx] <- "Age"#
#idx <- which(nm=="seniority")#
idx <- which(nm=="srvlng")#
nm[idx] <- "Seniority"#
idx <- which(nm=="gender")#
nm[idx] <- "Gender"#
idx <- which(nm=="race")#
nm[idx] <- "Race"#
#
pvars1 <- c("Gender", "Race", "Seniority", "Age", "DemVote", "PartyID", "Religion")#
colnames(tot105BIS) <- nm
#
parallel( ~tot105BIS[which( tot105BIS$hasGirls), pvars1], group= mymat2$w[which( tot105BIS$hasGirls)]>0,#
 alpha=c(0.05,0.2),  col=c("red","blue"),horizontal.axis=FALSE,scales = list(x = list(rot = 90)))
#
vvars <- c("gender",  "race",    "seniority",  "age" ,    "demvote" ,"repub"  , "region" , "rgroup" )#
#
d0 <- tot105[which( tot105$hasGirls), vvars]#
#
d2 <- tot105[which( tot105$hasGirls& mymat2$w>0), vvars]#
#
d3 <- tot105[which( tot105$hasGirls& mymat2$w==0), vvars]#
#
r1 <- c(prop.table(table(d0$gender))["Male"], prop.table(table(d2$gender))["Male"],  prop.table(table(d3$gender))["Male"])#
r2 <- c(mean(d0$seniority,na.rm=TRUE), mean(d2$seniority,na.rm=TRUE),  mean(d3$seniority,na.rm=TRUE))#
r3 <- c(mean(d0$age,na.rm=TRUE), mean(d2$age,na.rm=TRUE),  mean(d3$age,na.rm=TRUE))#
r4 <- c(mean(d0$demvote,na.rm=TRUE), mean(d2$demvote,na.rm=TRUE), mean(d3$demvote,na.rm=TRUE))#
r5 <- c(mean(d0$repub,na.rm=TRUE), mean(d2$repub,na.rm=TRUE),  mean(d3$repub,na.rm=TRUE))#
r6 <- c(prop.table(table(d0$race))["White"], prop.table(table(d2$race))["White"], prop.table(table(d3$race))["White"])#
r7 <- cbind(prop.table(table(d0$rgroup)), prop.table(table(d2$rgroup)), prop.table(table(d3$rgroup)))#
#
comptab <- rbind(r1, r2,r3,r4,r5,r6,r7)#
rownames(comptab) <- c("gender (% males)", "service length (years)", #
"age (years)", "dem. vote (%)", #
"republican (%)", #
"race (% white)", #
"religion: protestant (%)", "religion: none (%)", "religion: catholic (%)", #
"religion: other christian (%)", "religion: other (%)")#
colnames(comptab) <- c("raw data", "matched data", "unmatched data")#
#
tmptab <- comptab#
tmptab[8:7,] <- comptab[7:8,]#
rownames(tmptab)[8:7] <- rownames(comptab)[7:8]
vvars <- c("gender",  "race",    "srvlng",  "age" ,    "demvote" ,"repub"  , "region" , "rgroup" )#
#
#
d0 <- tot105[which( tot105$hasGirls), vvars]#
#
d2 <- tot105[which( tot105$hasGirls& mymat2$w>0), vvars]#
#
d3 <- tot105[which( tot105$hasGirls& mymat2$w==0), vvars]#
#
r1 <- c(prop.table(table(d0$gender))["Male"], prop.table(table(d2$gender))["Male"],  prop.table(table(d3$gender))["Male"])#
r2 <- c(mean(d0$seniority,na.rm=TRUE), mean(d2$seniority,na.rm=TRUE),  mean(d3$seniority,na.rm=TRUE))#
r3 <- c(mean(d0$age,na.rm=TRUE), mean(d2$age,na.rm=TRUE),  mean(d3$age,na.rm=TRUE))#
r4 <- c(mean(d0$demvote,na.rm=TRUE), mean(d2$demvote,na.rm=TRUE), mean(d3$demvote,na.rm=TRUE))#
r5 <- c(mean(d0$repub,na.rm=TRUE), mean(d2$repub,na.rm=TRUE),  mean(d3$repub,na.rm=TRUE))#
r6 <- c(prop.table(table(d0$race))["White"], prop.table(table(d2$race))["White"], prop.table(table(d3$race))["White"])#
r7 <- cbind(prop.table(table(d0$rgroup)), prop.table(table(d2$rgroup)), prop.table(table(d3$rgroup)))#
#
comptab <- rbind(r1, r2,r3,r4,r5,r6,r7)#
rownames(comptab) <- c("gender (% males)", "service length (years)", #
"age (years)", "dem. vote (%)", #
"republican (%)", #
"race (% white)", #
"religion: protestant (%)", "religion: none (%)", "religion: catholic (%)", #
"religion: other christian (%)", "religion: other (%)")#
colnames(comptab) <- c("raw data", "matched data", "unmatched data")#
#
tmptab <- comptab#
tmptab[8:7,] <- comptab[7:8,]#
rownames(tmptab)[8:7] <- rownames(comptab)[7:8]
vvars <- c("gender",  "race",    "srvlng",  "age" ,    "demvote" ,"repub"  , "region" , "rgroup" )#
#
#
d0 <- tot105[which( tot105$hasGirls), vvars]#
#
d2 <- tot105[which( tot105$hasGirls& mymat2$w>0), vvars]#
#
d3 <- tot105[which( tot105$hasGirls& mymat2$w==0), vvars]#
#
r1 <- c(prop.table(table(d0$gender))["Male"], prop.table(table(d2$gender))["Male"],  prop.table(table(d3$gender))["Male"])#
#r2 <- c(mean(d0$seniority,na.rm=TRUE), mean(d2$seniority,na.rm=TRUE),  mean(d3$seniority,na.rm=TRUE))#
r2 <- c(mean(d0$srvlng,na.rm=TRUE), mean(d2$srvlng,na.rm=TRUE),  mean(d3$srvlng,na.rm=TRUE))#
#
r3 <- c(mean(d0$age,na.rm=TRUE), mean(d2$age,na.rm=TRUE),  mean(d3$age,na.rm=TRUE))#
r4 <- c(mean(d0$demvote,na.rm=TRUE), mean(d2$demvote,na.rm=TRUE), mean(d3$demvote,na.rm=TRUE))#
r5 <- c(mean(d0$repub,na.rm=TRUE), mean(d2$repub,na.rm=TRUE),  mean(d3$repub,na.rm=TRUE))#
r6 <- c(prop.table(table(d0$race))["White"], prop.table(table(d2$race))["White"], prop.table(table(d3$race))["White"])#
r7 <- cbind(prop.table(table(d0$rgroup)), prop.table(table(d2$rgroup)), prop.table(table(d3$rgroup)))#
#
comptab <- rbind(r1, r2,r3,r4,r5,r6,r7)#
rownames(comptab) <- c("gender (% males)", "service length (years)", #
"age (years)", "dem. vote (%)", #
"republican (%)", #
"race (% white)", #
"religion: protestant (%)", "religion: none (%)", "religion: catholic (%)", #
"religion: other christian (%)", "religion: other (%)")#
colnames(comptab) <- c("raw data", "matched data", "unmatched data")#
#
tmptab <- comptab#
tmptab[8:7,] <- comptab[7:8,]#
rownames(tmptab)[8:7] <- rownames(comptab)[7:8]
#
#
require(xtable)#
#
xtable(tmptab)
